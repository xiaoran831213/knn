projection_gradient <- function(ViList, A0, p, maxiter = 5e3, tol = 1e-5)
{
  n     <- dim(A0)[1];
  k     <- length(ViList);
  V     <- Reduce(f = '+', ViList);
  A_pre <- A0;
  f_pre <- 0;
  f_pst <- 0;
  
  para  <- rep(0, maxiter);
  
  for(s in 1:maxiter)
  {
    A_pre  <- A_pre - 2*(1/s)*V%*%A_pre%*%V;
    #A_post <- Dykstra_projection(A_pre, ViList, p, maxiter = 100);
    A_post <- alter_projection(A_pre, ViList, p);
    
    # Calculate value of target function
    # f_best <- min(sum((A_post %*% V)^2), f_best);
    
    cat(s, ": ", sum((A_pre - A_post)^2), "\n")
    
    if(sum((A_pre - A_post)^2) < tol)
    {
      A_pre <- A_post;
      break;
    }else
    {
      A_pre <- A_post
    }
  }
  
  return(A_post)
}


# Alternating Projection Theorem
alter_projection <- function(X, ViList, p, maxiter = 5e3)
{
  for(s in 1:maxiter)
  {
    # Project X onto the positive semi-definite cone 
    eigA   <- eigen(X);
    QMat   <- eigA$vectors;
    vecD   <- pmax(eigA$values, 0);
    Y      <- QMat %*% diag(vecD) %*% t(QMat);
    
    # Project Y onto the affine space generated by the equality constraints
    G <- matrix(0, nrow = k, ncol = k);
    b <- rep(0,k);
    
    for(i in 1:k)
    {
      b[i] <- sum(ViList[[i]] * Y) - p[i];
      
      for(j in 1:i)
      {
        G[i,j] <- G[j,i] <- sum(ViList[[i]] * ViList[[j]]);
      }
    }
    
    u      <- ginv(G) %*% b;
    uAList <- mapply(FUN = '*', ViList, u, SIMPLIFY = FALSE);
    uA     <- Reduce(f = '+', uAList);
    X_new  <- Y - uA;
    X_new  <- (X_new + t(X_new))/2;
    Q0     <- Y + Q0 - X_new;
    
    diff   <- sum((X-X_new)^2);
    cat(diff, "\n")
    
    if(diff < tol)
    {
      X      <- X_new;
      break;
    }else
    {
      X      <- X_new;
    }
    
    
  }
  
  return(X)
}


# Dykstra's Projection Algorithm
Dykstra_projection <- function(X, ViList, p, maxiter = 5e3)
{
  P0 <- Q0 <- 0;
  
  for(s in 1:maxiter)
  {
    # Project X + P0 onto the positive semi-definite cone 
    eigA   <- eigen(X + P0);
    QMat   <- eigA$vectors;
    vecD   <- pmax(eigA$values, 0);
    Y      <- QMat %*% diag(vecD) %*% t(QMat);
    P0     <- X + P0 - Y;
    
    
    
    # Project Y + Q0 onto the affine space generated by the equality constraints
    G <- matrix(0, nrow = k, ncol = k);
    b <- rep(0,k);
    
    for(i in 1:k)
    {
      b[i] <- sum(ViList[[i]] * (Y + Q0)) - p[i];
      
      for(j in 1:i)
      {
        G[i,j] <- G[j,i] <- sum(ViList[[i]] * ViList[[j]]);
      }
    }
    
    u      <- ginv(G) %*% b;
    uAList <- mapply(FUN = '*', ViList, u, SIMPLIFY = FALSE);
    uA     <- Reduce(f = '+', uAList);
    X_new  <- Y + Q0 - uA;
    X_new  <- (X_new + t(X_new))/2;
    Q0     <- Y + Q0 - X_new;
    
    
    diff   <- sum((X-X_new)^2);
    cat(diff, "\n")
    X      <- X_new;

    
  }
  
  return(X)
  
}